= CI/CD, le divorce serait-prononcé ?
:source-highlighter: highlightjs

== CI / CD c'est quoi ?

Reprenons quelques définitions

=== Continuous Integration

Ensemble de contrôles permettant de fournir un retour rapide sur les développements :

* Qualité
* Non regression
* Respect de règles
* etc.

[.notes]
--
On travaille ici directement sur le code/le produit
On automatise via les outils d'intégration continue
Peu importe l'outillage, ça va dépendre des contraintes (techniques, sécurité, etc.) et de ce qu'on cherche à vérifier

Petit rappel, sur l'origine de l'intégration continue "on vérifie que chaque brick fonctionne les unes avec les autres"
--

=== CI : Les classiques

* Build : construction de l'application (compilation, dépendances, etc.)
* Tests : unitaire, fonctionnel, etc.
* Contrôle de qualité : Sonar, Linter, etc.

=== CI

Non dépendant de l'environnement cible

[.notes]
--
Potentiellement, on doit pouvoir faire fonctionner notre CI n'importe où
--

=== Continuous Delivery/Deployment

Delivery : on publie à la fin de notre process
Deployment : on déploie à la fin de notre process

=== CD

Dépendant :

* de l'environnement
* du cycle de déploiement/livraison de l'entreprise
* des responsables du produit

[.notes]
--
Workflow git pour le déploiement
Outillage pour le déploiement (s'il y a)
Phase de testing
Nombre de plateforme/environnement
etc ..
--

=== CD

Ce n'est plus "que de la technique".

=== Et un peu de vocabulaire

* Process : ensemble d'action fait à la suite les uns des autres pour obtenir un résultat (un algo quoi !)
* PIC : Plateforme d'Intégration Continue (outils permettant d'automatiser les process de CI/CD)

== La pratique des pipelines

(HDD : Hype Driven Development :D)

== Une méthode plus que des outils

* Pipeline == implémentation d'un process de CI/CD
* Pipeline != script

=== Proposition d'étapes

=== 1 - Définir les objectifs de notre CI

Définition des contraintes du projet :

* Besoin spécifique en perf/sécurité/qualité/accessibilité, etc ?
* Build complexe ? Multi plateforme ?
* Règles de l'entreprise à respecter (nommage, peu importe en fait)
* Qui doit voir quoi ? quand ? et surtout comment ?

[.notes]
--
Typiquement, on ne va pas attendre la même chose de la CI sur du Web que d'une appli lourde pour des drones.
--

=== 2 - Analyser les process de dev/déploiement existant

Mise en place d'une CI :

* Normalisation du process de dev
* Ne pas "révolutionner" le process de dev
* C'est un outil qui doit aider et non pas être une contrainte

[.notes]
--
On va chercher une adhésion des utilisateurs, sinon c'est inutile ou ce sera mal vécu
--

=== 3 - Etapes clés/cas particuliers

On va déterminer les étapes clés du process (souvent lors d'un changement d'acteur)

Ex.:

* On déploie tous les mois
* On a une équipe dédiée à vérifier que les titres sont en rouge
* Il n'y a que le lead qui peut builder l'application
* Les clés d'accès aux plateformes sont détenus par le chef uniquement

=== 4 - Les retours/métriques

En fonction des utilisateurs :

* Niveau de précision (un indicateur/la totale)
* Facilité d'accès (page web, envoie de mail, fichier, mail, etc.)
* Intégration dans un système existant ?

=== 5 - Automatiser ou ne pas automatiser ?

Tout automatiser n'est pas toujours (voir rarement) la meilleure solution.

* Complexité
* Process
* Equipes dev/ops différentes
* CI / CD : problématiques/besoins différents
* Déploiement auto sur tous les environnements ?

[.notes]
--
C'est à ce moment qu'on se rend compte que CI et CD ne sont pas DU TOUT le même chose, en particulier pour du déploiement auto
Ca permet d'éliminer immédiatement des problématiques d'implémentation
MAIS ça reste de le process
--

=== 6 - Choix des outils

On peut enfin choisir l'outillage.

* Ils doivent pouvoir implémenter les règles découvertes par les étapes précédentes
* CI : on se calle généralement sur les outils classiques du langage/metier
* CD : ... ben ça dépend des stacks, process, etc.

=== 7 - On commence seulement à implémenter

* On a les process
* On a les acteurs
* On a les métriques
* On a les outils

Let's go dev !

== L'ère du "All As Code"

All as Code :

* Reproductibilité
* Maintenabilité
* Versionning

[.notes]
--
On passe rapidement sur les avantages, de toute façon l'audience devrait déjà les connaitres
--

=== Gestion des sources

[source,bash]
----
.eslintrc
.jenkins/
.terraform/
.docker/
docs/
Jenkinsfile
sonar-project.properties
package.json
Dockerfile
...
----

[.notes]
--
Voici à quoi ressemble la racine de nos projets maintenant
--

=== C'est le bordel

=== Quelques conseils

* Favoriser les outils configurables par fichier
* Utiliser le nommage standard (si existant)
* Définir des règles d'organisation
* Export de certaines conf. dans un autre dépôt git ?

[.notes]
--
Pourquoi les standards ? car TOUTES les documentations utilisent les règles standards et tout le monde les connait
Vous allez avoir autre chose à maintenir qu'un nommage spécifique à votre entreprise/projet
Par exemple, nous mettons un point devant nos repertoires de configuration
Export : pour les pipelines standardisés
--

=== Utiliser les standards

* Connus
* Documentés
* Un truc de moins à maintenir

[.notes]
--
Ex. les fichiers de configuration, ne nous amuser à pas les renommer, vous allez galérer à les maintenir
--

== Parallèle avec les pratiques de dev

A final, on retombe sur des problématiques classiques de développement.

== Factorisation & Reuse

* Factoriser les jobs unitaires si le SOLID est bien respecté
* Sinon copier coller

=== Ex. Job Sonar - the bad way (OpenClosed principle broken)

[source,yaml]
----
.sonar:
  image:
    name: $CI_IMAGE_SONAR_SCANNER
    entrypoint: [""]
  variables:
    SONAR_HOST_URL: 'http://mon-sonar'
    SONAR_TOKEN: 'mon token'
    PROJECT_KEY: ''
    GIT_DEPTH: 0
    PROJECT_VERSION: $CI_COMMIT_REF_SLUG
  script:
    - sonar-scanner
      -Dsonar.qualitygate.wait=true
      -Dsonar.projectKey=$PROJECT_KEY
      -Dsonar.projectVersion=$PUBLISH_VERSION
      -Dsonar.sources=./src
      -Dsonar.tests=tests/
----

[.notes]
--
Ici, on impose une organisation aux sources du projet, c'est dommage et bloquant. EN gros, on ne respecte pas l'openclosed principe. La moindre modification est complexe.
--

=== Ex. Job Sonar - the good way

[source,yaml]
----
.sonar:
  image:
    name: $CI_IMAGE_SONAR_SCANNER
    entrypoint: [""]
  variables:
    SONAR_HOST_URL: ''
    SONAR_TOKEN: ''
    PROJECT_KEY: ''
    GIT_DEPTH: 0
    PROJECT_VERSION: $CI_COMMIT_REF_SLUG
  script:
    - sonar-scanner
      -Dsonar.qualitygate.wait=true
      -Dsonar.projectKey=$PROJECT_KEY
      -Dsonar.projectVersion=$PUBLISH_VERSION
      -Dproject.settings=./sonar-project.properties
----

[.notes]
--
Ici, on impose certaines règles relatives à sonar (project key, version), mais on laisse le reste extensible via les sonar properties
Pas de modification à faire en fonction du projet
--

=== Le découplage

* Single responsability par exemple
* Organiser vos jobs/steps comme vous découperiez des classes
* Une approche développement par contrat (AKA interface) pour chaque jobs/steps
* Bonus : Ca simplifiera le reuse et la factorisation

"De quoi j'ai besoin pour effectuer cette action, qu'est ce que je livre en sortie"

=== Gestion de l'erreur

=== Pipeline micro-services ?

== Allons plus loin
