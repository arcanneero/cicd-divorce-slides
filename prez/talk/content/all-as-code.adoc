= L'ère du "All As Code"

All as Code :

* Reproductibilité
* Maintenabilité
* Versionning

[.notes]
--
On passe rapidement sur les avantages, de toute façon l'audience devrait déjà les connaitres
--

== Gestion des sources

[source,bash]
----
.eslintrc
.jenkins/
.terraform/
.docker/
docs/
Jenkinsfile
sonar-project.properties
package.json
Dockerfile
...
----

[.notes]
--
Voici à quoi ressemble la racine de nos projets maintenant
--

== C'est le bordel

== Quelques conseils

* Favoriser les outils configurables par fichier
* Utiliser le nommage standard (si existant)
* Définir des règles d'organisation
* Export de certaines conf. dans un autre dépôt git ?

[.notes]
--
Pourquoi les standards ? car TOUTES les documentations utilisent les règles standards et tout le monde les connait
Vous allez avoir autre chose à maintenir qu'un nommage spécifique à votre entreprise/projet
Par exemple, nous mettons un point devant nos repertoires de configuration
Export : pour les pipelines standardisés
--

== Utiliser les standards

* Connus
* Documentés
* Un truc de moins à maintenir

[.notes]
--
Ex. les fichiers de configuration, ne nous amuser à pas les renommer, vous allez galérer à les maintenir
--

== Parallèle avec les pratiques de dev

Au final, on retombe sur des problématiques classiques de développement.

== Quelques REX

== Le cas "Générique à donf" (MEAE)

* Peu importe la technos, on veut les même étapes pour :
** Java
** Javascript
** Typescript
** Framework maison basé sur React

[.notes]
--
* Décrire les étapes à réaliser est très différent de les automatiser.
* Du coup, on est parti sur le classique TU, build, quality, deliver, deploy integration, TF
--

=== Les étapes prévues

* TU
* Build
* Quality
* Deliver
* Deploy integration
* TF

=== Problème : Code compilé vs code Exécuté

* Pour faire les tests en Typescript, il faut builder d'abord
* Pas besoins en Javascript

Donc :

* Build pour les tests ?
* TU
* Build pour la release ?
* Quality

[.notes]
--
Des problèmes de cas particulier, de généricité, viennent polluer vos scripts, comme on en rencontre de le dev classique
--

=== Résultats

* On passe plus de temps à maintenir le process dû aux cas particuliers qu'à ajouter des fonctionnalités
* Réutilisation des jobs/stages très complexes

=== Quelques solutions

* Soit avoir un pipeline (script) générique trèèèèès haut niveau (avec seulement les I/O de chaque job, et l'ordre d'exécution et encore)
* Soit pas de pipeline (script) générique






== Factorisation & Reuse

* Factoriser les jobs unitaires si le SOLID est bien respecté
* Sinon copier coller

=== Ex. Job Sonar - the bad way (OpenClosed principle broken)

[source,yaml]
----
.sonar:
  image:
    name: $CI_IMAGE_SONAR_SCANNER
    entrypoint: [""]
  variables:
    SONAR_HOST_URL: 'http://mon-sonar'
    SONAR_TOKEN: 'mon token'
    PROJECT_KEY: ''
    GIT_DEPTH: 0
    PROJECT_VERSION: $CI_COMMIT_REF_SLUG
  script:
    - sonar-scanner
      -Dsonar.qualitygate.wait=true
      -Dsonar.projectKey=$PROJECT_KEY
      -Dsonar.projectVersion=$PUBLISH_VERSION
      -Dsonar.sources=./src
      -Dsonar.tests=tests/
----

[.notes]
--
Ici, on impose une organisation aux sources du projet, c'est dommage et bloquant. EN gros, on ne respecte pas l'openclosed principe. La moindre modification est complexe.
--

=== Ex. Job Sonar - the good way

[source,yaml]
----
.sonar:
  image:
    name: $CI_IMAGE_SONAR_SCANNER
    entrypoint: [""]
  variables:
    SONAR_HOST_URL: ''
    SONAR_TOKEN: ''
    PROJECT_KEY: ''
    GIT_DEPTH: 0
    PROJECT_VERSION: $CI_COMMIT_REF_SLUG
  script:
    - sonar-scanner
      -Dsonar.qualitygate.wait=true
      -Dsonar.projectKey=$PROJECT_KEY
      -Dsonar.projectVersion=$PUBLISH_VERSION
      -Dproject.settings=./sonar-project.properties
----

[.notes]
--
Ici, on impose certaines règles relatives à sonar (project key, version), mais on laisse le reste extensible via les sonar properties
Pas de modification à faire en fonction du projet
--

=== Le découplage

* Single responsability par exemple
* Organiser vos jobs/steps comme vous découperiez des classes
* Une approche développement par contrat (AKA interface) pour chaque jobs/steps
* Bonus : Ca simplifiera le reuse et la factorisation

"De quoi j'ai besoin pour effectuer cette action, qu'est ce que je livre en sortie"
